* State Pattern
  应用场景：
  有多个状态，状态会迁移，每个状态下有对应的动作。

  这类问题的三个核心的概念：
  1. 状态： 即系统当前的状态。如门的状态，有两个：开或关
  2. 事件： 促使状态变化的原因。如对门的操作有两个事件：推或拉。
  3. 动作： 在某个特定的状态下，需要进行的操作。

  主类包含一个状态类实例，指明当前的状态。状态抽象基类需要对所有事件定义一个成员函数，子类需要实现所有的函数，这样便可保证没有遗漏的情况（当然为了简单，基类可以提供默认的实现，只打印一条错误）。状态迁移的逻辑在状态子类中实现（即一个状态子类处理完一个事件后，将主类的当前状态设置为下一状态）。
  主类也应定义所有事件的成员函数，并代理给当前状态类实例的相应成员函数。
  每个状态类成员函数接受一个参数：主类的指针。通过主类的指针设置新的状态，以及执行状态对应的动作。
  状态类只对主类可见。状态类一般实现为单例（一般也没有成员变量，因此自动是一个monostate)。

  state pattern将状态迁移逻辑与动作分离。

  调用序列：
  | client | main class | state class   | main class   |
  |        | ->open     | ->open        | ->openAction |
  |        |            | set new state |              |
  客户调用主类的open函数，处理open这个事件； 主类调用当前状态实例的open函数，并将自己作为入参传入；状态类调用主类的openAction函数执行open事件的动作， 并将主类的状态设置为新的状态。
  由此可看出，状态类这一层的处理完全是新增的，仅仅用于处理状态迁移这个事情。

  Example:
  HWU plug in and plug out handle.
  状态：
  plugedout
  configuring
  configured

  如果动作是异步事件，状态类无法更新下一个状态，因为不知道事件处理的结果。