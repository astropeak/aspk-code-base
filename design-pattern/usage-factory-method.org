* factory method
  - 由于对象的种类总是多种，但处理他们的流程却相同。工厂方法用于将生成不同种类对象的操作统一，则基类对所有对象的所有处理将完全相同。
  - 

** benefit
   无参数的工厂方法模式将对不同对象的判断逻辑放在了客户端，通过为每一种对象提供一个类（这些类都继承自一个抽象类）。这样当要新增加一个子类时，则现有的类代码不需要修改，只要新增加一个子类即可。 这点对于软件的维护有帮助（相比修改一个已有类，新增一个类几乎不会有引入BUG的压力）。

   - 与C语言的类比
     相当于把C语言中的这一个接口
     #+begin_src C :includes <stdio.h>
     void process_cmd(char *cmd);
     #+end_src
     变为了两个(假设cmd只有两个取值：echo, cat)：
     #+begin_src C :includes <stdio.h>
     void process_cmd_echo();
     void process_cmd_cat();
     #+end_src
  
     如果需要新增加一个命令 ~ls~, 对于第一种接口， ~process_cmd~ 的代码必然要改变，因为它依赖于cmd的具体值。
     而对于第二种接口，只需要再新增一个 ~void process_cmd_ls()~ 的函数即可。
  
     对于C++， 新增这个命令时，不会存在复制粘贴的问题，因为公共代码在基类中。 

   由以上描述可看出：工厂方法将增加类的数目（这是应有的代价）。

   - 有助于实现软件的增量式开发，即添加新功能时，只是增加新的代码，而不修改已有代码。
   - 研究：增量式软件开发，插件式软件开发
     之前实现Log parser时，就是增量式开发，添加新的消息的解析，对已有代码完全没有影响。或者也是插件式的，即删除其中一个消息的解析，也对已有代码无影响。
** abstract factory pattern
   工厂方法： 将创建对象的操作封装在一个方法里， 子类提供具体的实现。
   抽象工厂： 将创建对象的操作封装在另一个类中（抽象工厂类），这个类只提供接口，这个类的具体类提供实现。

   二者的关系：
   - 大致相同， 工厂方法处理简单的情况，抽象工厂处理复杂的情况。
   - 类层次关系不同。

   抽象工厂的应用场景：
   - 需要多个元件，且元件有很多组类型，如
   