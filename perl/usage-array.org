* array
** splice
   add or remove element anywhere in an array.
   doc: http://www.perlmonks.org/?node=splice
   
   syntax:
   splice ARRAY, OFFSET, LENGTH, LIST
   replace (offset length) with list. If offset is negtive, then it count form end.
   
   Below lines are all have same effect:
   #+begin_src perl :results output
       push(@a,$x,$y)      splice(@a,@a,0,$x,$y)
       pop(@a)             splice(@a,-1)
       shift(@a)           splice(@a,0,1)
       unshift(@a,$x,$y)   splice(@a,0,0,$x,$y)
       $a[$x] = $y         splice(@a,$x,1,$y)
   #+end_src
   
   
** flatten array
*** definition
   (1, 2, (3, 4), 5) is the same as (1, 2, 3, 4, 5).
   #+begin_src perl :results output
   use Aspk::Debug;
   my @a=(1, 2, (3, 4), 5);
   dbgh \@a;
   
   #+end_src

   #+RESULTS:
   : [dbgh][./-:3, main::noname] \@a=ARRAY(0xa031cec)
   :      [0]:1
   :      [1]:2
   :      [2]:3
   :      [3]:4
   :      [4]:5
   : 

*** benifet
    1. In function body, function parameter will have the same form whether the actual parameter is an array or an scalar. It will always be an array.
       If the acutal parameter is ~(1, 2, 3)~, then ~@_~ is ~((1, 2, 3))~, which is the same as ~(1, 2, 3)~; if the acutal parameter is ~1~, then ~@_~ is ~(1)~. They are both an array. 
       Then program can treat them uniformly.
    